package net.corda.v5.ledger.utxo

import net.corda.v5.base.annotations.CordaSerializable
import net.corda.v5.base.annotations.DoNotImplement
import net.corda.v5.crypto.SecureHash
import net.corda.v5.ledger.common.transaction.Party
import java.io.FileNotFoundException
import java.io.IOException
import java.io.InputStream
import java.io.OutputStream
import java.security.PublicKey
import java.time.Duration
import java.time.Instant
import java.util.jar.JarInputStream

/**
 * Specifies UTXO transaction component groups.
 *
 * @property TRANSACTION_PARAMETERS The transaction parameters component group. Ordinal = 0.
 * @property MEMBERSHIP_PARAMETERS The membership parameters component group. Ordinal = 1.
 * @property PACKAGES The packages component group. Ordinal = 2.
 * @property SIGNATORIES The signatories component group. Ordinal = 3.
 * @property ATTACHMENTS The attachments component group. Ordinal = 4.
 * @property NOTARY The notary component group. Ordinal = 5.
 * @property TIME_WINDOW The time window component group. Ordinal = 6.
 * @property COMMANDS The commands component group. Ordinal = 7.
 * @property COMMANDS_METADATA The commands metadata component group. Ordinal = 8.
 * @property INPUTS The inputs component group. Ordinal = 9.
 * @property INPUTS_METADATA The inputs metadata component group. Ordinal = 10.
 * @property OUTPUTS The outputs component group. Ordinal = 11.
 * @property OUTPUTS_METADATA The outputs metadata component group. Ordinal = 12.
 * @property REFERENCES The references component group. Ordinal = 13.
 * @property REFERENCES_METADATA The references metadata component group. Ordinal = 14.
 */
enum class ComponentGroup {
    TRANSACTION_PARAMETERS, MEMBERSHIP_PARAMETERS, PACKAGES, SIGNATORIES, ATTACHMENTS, NOTARY, TIME_WINDOW, COMMANDS, COMMANDS_METADATA, INPUTS, INPUTS_METADATA, OUTPUTS, OUTPUTS_METADATA, REFERENCES, REFERENCES_METADATA
}

/**
 * Defines a data attachment that can be referenced within a transaction.
 *
 * Attachments are ZIP, or optionally a signed JAR file that contains one or more files of public, static data that
 * can be referenced from a transaction, and utilised within a contract. Examples of attachments include:
 *
 * - Calendar data
 * - Fixes (e.g. LIBOR)
 * - Smart contract code
 * - Legal documents
 * - Facts generated by oracles.
 *
 * @property id The unique hash of the attachment.
 * @property size The size of the attachment in bytes.
 * @property signatories The keys that have been used to sign the attachment, or empty if the attachment does not require signing.
 */
@CordaSerializable
@DoNotImplement
interface Attachment {

    val id: SecureHash
    val size: Int
    val signatories: Set<PublicKey>

    /**
     * Finds the specified file (case insensitively) within the attachment and copies it to the specified output stream.
     *
     * @param path The path of the file to find within the attachment.
     * @param output The output stream where the file should be copied to.
     * @throws [FileNotFoundException] if the specified path does not exist in the attachment.
     */
    fun extractFile(path: String, output: OutputStream)

    /**
     * Opens the current [Attachment].
     *
     * @return Returns the [InputStream] for the current [Attachment].
     */
    fun open(): InputStream

    /**
     * Opens the current [Attachment] as a JAR (Java Archive).
     *
     * @return Returns the [JarInputStream] for the current [Attachment].
     */
    fun openAsJar(): JarInputStream {
        val stream = open()
        return try {
            JarInputStream(stream)
        } catch (ex: IOException) {
            stream.use { throw ex }
        }
    }
}

/**
 * Defines an interval on a timeline; not a single, instantaneous point.
 *
 * There is no such thing as "exact" time in distributed systems, due to the underlying physics involved, and other
 * issues such as network latency. A time window represents an approximation of an instant with a margin of tolerance,
 * and may be fully bounded, or unbounded towards negative or positive infinity.
 *
 * @property from The boundary at which the time window begins, or null if the time window is unbounded towards negative infinity.
 * @property until The boundary at which the time window ends, or null if the time window is unbounded towards positive infinity.
 * @property midpoint The midpoint between a fully bounded time window, or null if the time window is unbounded towards positive or negative infinity.
 * @property duration The duration of a fully bounded time window, or null if the time window is unbounded towards positive or negative infinity.
 */
@DoNotImplement
@CordaSerializable
interface TimeWindow {
    val from: Instant?
    val until: Instant?
    val midpoint: Instant?
    val duration: Duration? get() = if (from == null || until == null) null else Duration.between(from, until)

    /**
     * Determines whether the current [TimeWindow] contains the specified [Instant].
     *
     * @param instant The [Instant] to check is contained within the current [TimeWindow].
     * @return Returns true if the current [TimeWindow] contains the specified [Instant]; otherwise, false.
     */
    operator fun contains(instant: Instant): Boolean
}

/**
 * Defines information that applies to a transaction state.
 *
 * @property contractId The class name of the [Contract] associated with the transaction state.
 * @property notary The [Party] of the notary associated with the transaction state.
 * @property encumbrance The index of an associated, encumbered state, or null if no encumbrance applies to the associated transaction state.
 * @property constraint The [CpkConstraint] associated with the transaction state.
 */
@DoNotImplement
@CordaSerializable
interface TransactionStateInformation {
    val contractId: String
    val notary: Party
    val encumbrance: Int?
    val constraint: CpkConstraint
}

/**
 * Defines a transaction state, composed of a [ContractState] and associated [TransactionStateInformation].
 *
 * @param T The underlying type of the [ContractState] instance.
 * @property contractState The [ContractState] component of the current [TransactionState] instance.
 * @property information The [TransactionStateInformation] component of the current [TransactionState] instance.
 */
@DoNotImplement
@CordaSerializable
interface TransactionState<out T : ContractState> {
    val contractState: T
    val information: TransactionStateInformation
}

/**
 * Represents a composition of a [TransactionState] and a [StateRef].
 *
 * @property state The [TransactionState] component of the current [StateAndRef].
 * @property ref The [StateRef] component of the current [StateAndRef].
 */
@DoNotImplement
@CordaSerializable
interface StateAndRef<out T : ContractState> {
    val state: TransactionState<T>
    val ref: StateRef
}

/**
 * Defines a reference to a [ContractState].
 *
 * @property index The index of the state in the transaction's outputs in which the referenced state was created.
 * @property transactionHash The hash of the transaction in which the referenced state was created.
 */
@DoNotImplement
@CordaSerializable
interface StateRef {
    val index: Int
    val transactionHash: SecureHash
}

/**
 * Represents input and output states that are grouped by a key that is common to all inputs and outputs.
 *
 * @constructor Creates a new instance of the [InputOutputGroup] data class.
 * @param T The underlying type of the grouped [ContractState] instances.
 * @param K The underlying type of the grouping key.
 * @property inputs The inputs that are grouped by the specified grouping key.
 * @property outputs The outputs that are grouped by the specified grouping key.
 * @property groupingKey The grouping key that is common to all grouped input and output states.
 */
@DoNotImplement
@CordaSerializable
interface InputOutputGroup<out T : ContractState, out K : Any> {
    val inputs: List<StateAndRef<T>>
    val outputs: List<StateAndRef<T>>
    val groupingKey: K
}
