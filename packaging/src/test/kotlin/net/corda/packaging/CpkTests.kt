package net.corda.packaging

import net.corda.packaging.internal.CpkLoader
import net.corda.packaging.internal.UncloseableInputStream
import net.corda.packaging.internal.ZipTweaker
import net.corda.packaging.internal.hash
import net.corda.v5.crypto.DigestAlgorithmName
import net.corda.v5.crypto.SecureHash
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.BeforeAll
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.TestInstance
import org.junit.jupiter.api.assertThrows
import org.junit.jupiter.api.io.TempDir
import java.io.ByteArrayInputStream
import java.io.ByteArrayOutputStream
import java.io.IOException
import java.io.InputStream
import java.net.URI
import java.nio.file.CopyOption
import java.nio.file.FileSystems
import java.nio.file.Files
import java.nio.file.LinkOption
import java.nio.file.Path
import java.security.DigestInputStream
import java.security.MessageDigest
import java.util.Base64
import java.util.jar.JarFile
import java.util.stream.Collectors
import java.util.zip.ZipEntry
import java.util.zip.ZipFile
import java.util.zip.ZipInputStream
import java.util.zip.ZipOutputStream

//This is to avoid extracting the CPK archive in every single test case,
// no test case writes anything to the filesystem, nor alters the state of the test class instance;
// this makes it safe to use the same instance for all test cases (test case execution order is irrelevant)
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class CpkTests {

    private lateinit var testDir : Path

    private lateinit var flowsCpkPath : Path
    private lateinit var workflowCpkPath : Path
    private lateinit var extractedWorkflowCpkPath : Path
    private lateinit var workflowCpk : Cpk.Expanded
    private lateinit var flowsCpk : Cpk
    private lateinit var cordappJarPath : Path
    private lateinit var referenceExtractionPath : Path
    private lateinit var nonJarFile : Path

    private lateinit var workflowCpkLibraries : Map<String, SecureHash>

    private val cordaDevKey = SecureHash.create("SHA-256" + ":" + System.getProperty("net.corda.dev.cert"))

    @BeforeAll
    fun setup(@TempDir junitTestDir : Path) {
        testDir = junitTestDir

        flowsCpkPath = Path.of(URI(System.getProperty("net.corda.flows.cpk")))
        flowsCpk = Cpk.Archived.from(Files.newInputStream(flowsCpkPath), flowsCpkPath.toString())
        workflowCpkPath = Path.of(URI(System.getProperty("net.corda.packaging.test.workflow.cpk")))
        extractedWorkflowCpkPath = testDir.resolve(workflowCpkPath.fileName)
        workflowCpk = Cpk.Expanded.from(Files.newInputStream(workflowCpkPath), extractedWorkflowCpkPath, workflowCpkPath.toString())
        cordappJarPath = Path.of(URI(System.getProperty("net.corda.packaging.test.workflow.cordapp")))
        nonJarFile = Files.createFile(testDir.resolve("someFile.bin"))
        workflowCpkLibraries = System.getProperty("net.corda.packaging.test.workflow.libs").split(' ').stream().map { jarFilePath ->
            val filePath = Path.of(URI(jarFilePath))
            filePath.fileName.toString() to computeSHA256Digest(Files.newInputStream(filePath))
        }.collect(Collectors.toUnmodifiableMap({it.first}, {it.second}))
        referenceExtractionPath = testDir.resolve("unzippedCpk")
        referenceUnzipMethod(workflowCpkPath, referenceExtractionPath)
    }


    companion object {
        private val DUMMY_HASH =
            Base64.getEncoder().encodeToString(SecureHash(DigestAlgorithmName.SHA2_256.name, ByteArray(32)).bytes)

        /** Unpacks the [zip] to an autogenerated temporary directory, and returns the directory's path. */
        fun referenceUnzipMethod(source: Path, destination : Path) {

            // We retrieve the relative paths of the zip entries.
            val zipEntryNames = ZipFile(source.toFile()).use { zipFile ->
                zipFile.entries().toList().map(ZipEntry::getName)
            }

            // We create a filesystem to copy the zip entries to a temporary directory.
            FileSystems.newFileSystem(source, null).use { fs ->
                zipEntryNames
                        .map(fs::getPath)
                        .filterNot(Path::isDirectory)
                        .forEach { path ->
                            val newDir = destination.resolve(path.toString())
                            Files.createDirectories(newDir.parent)
                            path.copyTo(newDir)
                        }
            }
        }

        private fun computeSHA256Digest(stream: InputStream, buffer: ByteArray = ByteArray(DEFAULT_BUFFER_SIZE)): SecureHash {
            val md = MessageDigest.getInstance(DigestAlgorithmName.SHA2_256.name)
            DigestInputStream(stream, md).use {
                while (it.read(buffer) >= 0) {
                    continue
                }
            }
            return SecureHash(DigestAlgorithmName.SHA2_256.name, md.digest())
        }
    }


    private fun tweakCordappJar(destination : Path, cordappJarTweaker : ZipTweaker) {
        object : ZipTweaker() {
            override fun tweakEntry(inputStream: ZipInputStream,
                                    outputStream: ZipOutputStream,
                                    currentEntry: ZipEntry,
                                    buffer : ByteArray) = if(currentEntry.name == workflowCpk.cordappJarFileName) {
                val baos = ByteArrayOutputStream()
                cordappJarTweaker.run(UncloseableInputStream(inputStream), baos)
                writeZipEntry(outputStream, { ByteArrayInputStream(baos.toByteArray()) }, currentEntry.name, buffer, ZipEntry.STORED)
                AfterTweakAction.DO_NOTHING
            } else {
                AfterTweakAction.WRITE_ORIGINAL_ENTRY
            }
        }.run(Files.newInputStream(workflowCpkPath), Files.newOutputStream(destination))
    }

    private fun tweakDependencyMetadataFile(destination : Path, xml : String) {
        val tweaker = object : ZipTweaker() {
            override fun tweakEntry(inputStream: ZipInputStream,
                                    outputStream: ZipOutputStream,
                                    currentEntry: ZipEntry,
                                    buffer: ByteArray) =
                    if (currentEntry.name == CpkLoader.DEPENDENCIES_FILE_ENTRY) {
                        val source = {
                            ByteArrayInputStream(xml.toByteArray())
                        }
                        writeZipEntry(outputStream, source, currentEntry.name, buffer, currentEntry.method)
                        AfterTweakAction.DO_NOTHING
                    } else AfterTweakAction.WRITE_ORIGINAL_ENTRY
        }
        tweakCordappJar(destination, tweaker)
    }

    @Test
    fun `Verify hashes of jars in the lib folder of workflow cpk`() {
        for(entry in workflowCpk.libraryDependencies) {
            Assertions.assertEquals(workflowCpkLibraries[entry.key], entry.value,
                    "The hash of library dependency '${entry.key}' of cpk file $workflowCpkPath from CPK.Metadata " +
                            "isn't consistent with the content of the file")
        }
    }

    @Test
    fun `Verify hash of main jar file`() {
        Assertions.assertEquals(computeSHA256Digest(Files.newInputStream(cordappJarPath)), workflowCpk.cordappHash,
                "The hash from Cpk.Metadata differs from the actual hash of the .jar file in $cordappJarPath")
    }

    @Test
    fun `Verify hash of cpk file`() {
        Assertions.assertEquals(computeSHA256Digest(Files.newInputStream(workflowCpkPath)), workflowCpk.cpkHash,
                "The cpk hash from Cpk.Metadata differs from the actual hash of the .cpk file")
    }

    @Test
    fun `Verify that extracted files aren't corrupt and none of them is missing`() {
        val buffer = ByteArray(DEFAULT_BUFFER_SIZE)
        Files.walk(referenceExtractionPath)
                .filter(Path::isRegularFile).forEach { filePath ->
            val relativePath = referenceExtractionPath.relativize(filePath)
            val referenceFileHash = computeSHA256Digest(Files.newInputStream(filePath), buffer)
            val extractedFile = extractedWorkflowCpkPath.resolve("content").resolve(relativePath)
            Assertions.assertTrue(Files.exists(extractedFile), "Missing file '$relativePath' from cpk extraction folder")
            val extractedFileHash = computeSHA256Digest(Files.newInputStream(extractedFile), buffer)
            Assertions.assertEquals(referenceFileHash, extractedFileHash, "$filePath differs from $extractedFileHash")
        }
    }

    @Test
    fun `Verify mainJarUri URI is correct`() = Assertions.assertTrue(Files.exists(workflowCpk.mainJar))

    @Test
    fun `Verify library files are correct`() {
        Assertions.assertEquals(workflowCpkLibraries.size, workflowCpk.libraries.size)
        workflowCpk.libraries.forEach {
            Assertions.assertTrue(Files.exists(it))
        }
        for(library in workflowCpk.libraries) {
            val libraryHash = try {
                 computeSHA256Digest(Files.newInputStream(library))
            } catch(e : IOException) {
                Assertions.fail(e)
            }
            val fileName = library.fileName.toString()
            Assertions.assertEquals(libraryHash, workflowCpkLibraries[fileName],
                    "The hash of library dependency '${fileName}' of cpk file $workflowCpkPath from CPK.libraryUris " +
                            "isn't consistent with the content of the file")
        }
    }

    @Test
    fun `Verify CPK dependencies are correct`() {
        val dependencies = workflowCpk.dependencies
        Assertions.assertEquals(1, dependencies.size)
        val contractCpkDependency = dependencies.single()

        contractCpkDependency.apply {
            Assertions.assertEquals(System.getProperty("net.corda.packaging.test.contract.bundle.symbolic.name"), symbolicName)
            Assertions.assertEquals(System.getProperty("net.corda.packaging.test.contract.bundle.version"), version)
            Assertions.assertEquals(cordaDevKey.toString().toByteArray().hash(), signerSummaryHash,
        "The cpk dependency is expected to be signed with corda development key only"
            )
        }
    }

    @Test
    fun `Verify cordapp signature`() {
        Assertions.assertEquals(setOf(cordaDevKey),
                workflowCpk.cordappCertificates
                    .asSequence().map { it.publicKey.encoded.hash() }.toSet()
        )
    }

    @Test
    fun `throws if CorDapp JAR has no manifest`() {
        val modifiedWorkflowCpk = testDir.resolve("tweaked.cpk")
        val tweaker = object : ZipTweaker() {
            override fun tweakEntry(inputStream: ZipInputStream,
                                    outputStream: ZipOutputStream,
                                    currentEntry: ZipEntry,
                                    buffer: ByteArray) =
                    if (currentEntry.name == JarFile.MANIFEST_NAME) AfterTweakAction.DO_NOTHING
                    else AfterTweakAction.WRITE_ORIGINAL_ENTRY
        }
        tweakCordappJar(modifiedWorkflowCpk, tweaker)
        assertThrows<CordappManifestException> {
            Cpk.Archived.from(Files.newInputStream(modifiedWorkflowCpk),
                    cpkLocation = modifiedWorkflowCpk.toString(),
                    verifySignature = false)
        }
    }

    @Test
    fun `throws if a CPK does not have a dependencies file`() {
        val modifiedWorkflowCpk = testDir.resolve("tweaked.cpk")
        val tweaker = object : ZipTweaker() {
            override fun tweakEntry(inputStream: ZipInputStream,
                                    outputStream: ZipOutputStream,
                                    currentEntry: ZipEntry,
                                    buffer: ByteArray) =
                    if (currentEntry.name == CpkLoader.DEPENDENCIES_FILE_ENTRY) {
                        val source = {
                            ByteArrayInputStream("<<<<<This is clearly invalid XML content".toByteArray())
                        }
                        writeZipEntry(outputStream, source, currentEntry.name, buffer, currentEntry.method)
                        AfterTweakAction.DO_NOTHING
                    } else AfterTweakAction.WRITE_ORIGINAL_ENTRY
        }
        tweakCordappJar(modifiedWorkflowCpk, tweaker)
        assertThrows<DependencyMetadataException> {
            Cpk.Archived.from(Files.newInputStream(modifiedWorkflowCpk),
                    cpkLocation = modifiedWorkflowCpk.toString(), verifySignature = false)
        }
    }

    @Test
    fun `does not complain if a CPK dependencies file lists no dependencies`() {
        val modifiedWorkflowCpk = testDir.resolve("tweaked.cpk")
        val xml = """
        |<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
        |<cpkDependencies xmlns="urn:corda-cpk">
        |</cpkDependencies>
        """.trimMargin()
        tweakDependencyMetadataFile(modifiedWorkflowCpk, xml)
        Assertions.assertDoesNotThrow {
            Cpk.Archived.from(Files.newInputStream(modifiedWorkflowCpk),
                    cpkLocation = modifiedWorkflowCpk.toString(), verifySignature = false)
        }
    }

    @Test
    fun `throws if a CPK dependencies file lists a dependency with no signers`() {
        val modifiedWorkflowCpk = testDir.resolve("tweaked.cpk")
        val xml = """
        |<cpkDependencies xmlns="urn:corda-cpk">
        |    <cpkDependency>
        |        <name>DUMMY_NAME</name>
        |        <version>DUMMY_VERSION</version>
        |    </cpkDependency>
        |</cpkDependencies>
        """.trimMargin()
        tweakDependencyMetadataFile(modifiedWorkflowCpk, xml)
        assertThrows<DependencyMetadataException> {
            Cpk.Archived.from(Files.newInputStream(modifiedWorkflowCpk),
                    cpkLocation = modifiedWorkflowCpk.toString(), verifySignature = false)
        }
    }

    @Test
    fun `throws if a CPK dependencies file lists a dependency with a signer but no algorithm`() {
        val modifiedWorkflowCpk = testDir.resolve("tweaked.cpk")
        val xml = """
        |<cpkDependencies xmlns="urn:corda-cpk">
        |    <cpkDependency>
        |        <name>DUMMY_NAME</name>
        |        <version>DUMMY_VERSION</version>
        |        <signers>
        |            <signer>${DUMMY_HASH}</signer>
        |        </signers>
        |    </cpkDependency>
        |</cpkDependencies>
        """.trimMargin()
        tweakDependencyMetadataFile(modifiedWorkflowCpk, xml)
        assertThrows<DependencyMetadataException> {
            Cpk.Archived.from(Files.newInputStream(modifiedWorkflowCpk),
                    cpkLocation = modifiedWorkflowCpk.toString(), verifySignature = false)
        }
    }

    @Test
    fun `allows a CPK dependencies file to list multiple signers`() {
        val publicKey = "some public key".toByteArray()
        val dummyName = "DUMMY_NAME"
        val dummyVersion = "DUMMY_VERSION"
        val hashdata1 = publicKey.hash(DigestAlgorithmName.SHA2_384)
        val hashdata2 = publicKey.hash(DigestAlgorithmName.SHA2_384)
        val hashdata3 = publicKey.hash(DigestAlgorithmName.SHA2_512)
        val expectedSignersSummaryHash = hash { md ->
            sequenceOf(hashdata1, hashdata2, hashdata3)
                .sortedWith(Cpk.Identifier.secureHashComparator)
                .map(SecureHash::toString)
                .map(String::toByteArray)
                .forEach(md::update)
        }

        val modifiedWorkflowCpk = testDir.resolve("tweaked.cpk")
        val xml = """
        |<cpkDependencies xmlns="urn:corda-cpk">
        |    <cpkDependency>
        |        <name>$dummyName</name>
        |        <version>$dummyVersion</version>
        |        <signers>
        |            <signer algorithm="${hashdata1.algorithm}">${String(Base64.getEncoder().encode(hashdata1.bytes))}</signer>
        |            <signer algorithm="${hashdata2.algorithm}">${String(Base64.getEncoder().encode(hashdata2.bytes))}</signer>
        |            <signer algorithm="${hashdata3.algorithm}">${String(Base64.getEncoder().encode(hashdata3.bytes))}</signer>
        |        </signers>
        |    </cpkDependency>
        |</cpkDependencies>
        """.trimMargin()
        tweakDependencyMetadataFile(modifiedWorkflowCpk, xml)
        val cpk = Cpk.Archived.from(Files.newInputStream(modifiedWorkflowCpk),
                    cpkLocation = modifiedWorkflowCpk.toString(), verifySignature = false)
        val dependency = cpk.dependencies.find { it.symbolicName == dummyName && it.version == dummyVersion }
        Assertions.assertNotNull(dependency, "Test dependency not found")
        Assertions.assertEquals(expectedSignersSummaryHash, dependency!!.signerSummaryHash)
    }

    @Test
    fun `signature verification fails if archive has been tampered with`() {
        val modifiedWorkflowCpk = testDir.resolve("tweaked.cpk")
        val xml = """
        |<cpkDependencies xmlns="urn:corda-cpk">
        |</cpkDependencies>
        """.trimMargin()
        tweakDependencyMetadataFile(modifiedWorkflowCpk, xml)
        Assertions.assertThrows(InvalidSignatureException::class.java) {
            Cpk.Archived.from(Files.newInputStream(modifiedWorkflowCpk), verifySignature = true)
        }
    }

    @Test
    fun `throws if archive is not a jar file at all`() {
        assertThrows<PackagingException> {
            Cpk.Archived.from(Files.newInputStream(nonJarFile), nonJarFile.toString())
        }
        assertThrows<PackagingException> {
            Cpk.Expanded.from(Files.newInputStream(nonJarFile), extractedWorkflowCpkPath, nonJarFile.toString())
        }
    }

    @Test
    fun `corda-api dependencies are not included in cpk dependencies`() {
        Assertions.assertTrue(workflowCpk.dependencies.none {
            it == flowsCpk.id
        })
    }

    @Test
    fun `signers summary hash is computed correctly`() {
        val md = MessageDigest.getInstance(DigestAlgorithmName.DEFAULT_ALGORITHM_NAME.name)
        md.update(cordaDevKey.toString().toByteArray())
        val expectedHash = SecureHash(DigestAlgorithmName.DEFAULT_ALGORITHM_NAME.name, md.digest())
        Assertions.assertEquals(expectedHash, flowsCpk.id.signerSummaryHash)
    }
}

/** @see Files.copy */
fun Path.copyTo(target: Path, vararg options: CopyOption): Path = Files.copy(this, target, *options)

/** @see Files.isDirectory */
fun Path.isDirectory(vararg options: LinkOption): Boolean = Files.isDirectory(this, *options)

/** @see Files.isRegularFile */
fun Path.isRegularFile(vararg options: LinkOption): Boolean = Files.isRegularFile(this, *options)
