<?xml version="1.1" encoding="UTF-8" standalone="no"?>
<databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                   xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.3.xsd">
    <changeSet author="R3.Corda" id="crypto-creation-v1.0">
        <createTable tableName="crypto_wrapping_key">
            <column name="alias" type="VARCHAR(64)">
                <constraints nullable="false"/>
            </column>
            <!-- version of the wrapping key, as a UUID -->
            <column name="version" type="VARCHAR(64)">
                <constraints nullable="false"/>
            </column>
            <column name="created" type="TIMESTAMP">
                <constraints nullable="false"/>
            </column>
            <column name="encoding_version" type="INT">
                <constraints nullable="false"/>
            </column>
            <column name="algorithm_name" type="VARCHAR(64)">
                <constraints nullable="false"/>
            </column>
            <!-- key material will be null for keys stored outside the database, 
                 e.g. dervied from configuration parameters --> 
            <column name="key_material" type="VARBINARY(1048576)">
                <constraints nullable="true"/>
            </column>
            <!-- if null, there should be automated rotation -->
            <column name="rotation_date" type="TIMESTAMP">
                <constraints nullable="true"/>
            </column>
            <!-- FK to the other key alias that was used to encrypt this wrapping key.
                That other key will also be a wrapping key, hence the awkward name -->
            <column name="wrapping_alias" type="VARCHAR(64)">
                <constraints nullable="true"/>
            </column>
            <!-- FK to the other key version that was used to encrypt this wrapping key.
                That other key will also be a wrapping key, hence the awkward name -->
            <column name="wrapping_version" type="VARCHAR(64)">
                <constraints nullable="true"/>
            </column>
        </createTable>
        <addPrimaryKey  columnNames="alias, version"
                        tableName="crypto_wrapping_key"
                        constraintName="crypto_wrapping_key_pk"/>
        <addForeignKeyConstraint baseColumnNames="wrapping_alias, wrapping_version"
                                 baseTableName="crypto_wrapping_key"
                                 onUpdate="RESTRICT"
                                 onDelete="RESTRICT"
                                 referencedColumnNames="alias, version"
                                 referencedTableName="crypto_wrapping_key"
                                 constraintName="fk__crypto_wrapping_key_parent_key"
                                 validate="true"/>         
        <createTable tableName="crypto_hsm_association">
            <column name="id" type="VARCHAR(36)">
                <constraints nullable="false"/>
            </column>
            <column name="tenant_id" type="VARCHAR(12)">
                <constraints nullable="false"/>
            </column>
            <column name="hsm_id" type="VARCHAR(36)">
                <constraints nullable="false"/>
            </column>
            <column name="timestamp" type="TIMESTAMP">
                <constraints nullable="false"/>
            </column>
            <column name="master_key_alias" type="VARCHAR(30)">
                <constraints nullable="true"/>
            </column>
        </createTable>
        <addPrimaryKey  columnNames="id"
                        tableName="crypto_hsm_association"
                        constraintName="crypto_hsm_association_pk"/>
        <addUniqueConstraint columnNames="tenant_id, hsm_id"
                             tableName="crypto_hsm_association"
                             constraintName="crypto_hsm_association_uc"/>

        <createTable tableName="crypto_hsm_category_association">
            <column name="id" type="VARCHAR(36)">
                <constraints nullable="false"/>
            </column>
            <column name="tenant_id" type="VARCHAR(12)">
                <constraints nullable="false"/>
            </column>
            <column name="category" type="VARCHAR(20)">
                <constraints nullable="false"/>
            </column>
            <column name="hsm_association_id" type="VARCHAR(36)">
                <constraints nullable="false"/>
            </column>
            <column name="timestamp" type="TIMESTAMP">
                <constraints nullable="false"/>
            </column>
            <column name="deprecated_at" type="BIGINT">
                <constraints nullable="false"/>
            </column>
        </createTable>
        <addPrimaryKey  columnNames="id"
                        tableName="crypto_hsm_category_association"
                        constraintName="crypto_hsm_category_association_pk"/>
        <addUniqueConstraint columnNames="tenant_id, category, deprecated_at"
                             tableName="crypto_hsm_category_association"
                             constraintName="crypto_hsm_category_association_uc"/>
        <addForeignKeyConstraint  baseColumnNames="hsm_association_id"
                                  baseTableName="crypto_hsm_category_association"
                                  referencedColumnNames="id"
                                  referencedTableName="crypto_hsm_association"
                                  constraintName="crypto_hsm_category_association_fk1"/>
        <!--
        For now, the crypto_signing_key table schema must be identical between here and the 
        virtual node schema (in ../../crypto/migration/crypto-creation-v1.0.xml)
        since the crypto processor uses the same code irrespective of where the table resides.
       
        We could just include the same changeset files in both cases, but that might confuse readers
        and liquibase, so instead we have to keep the content in sync.  
        -->
        <createTable tableName="crypto_signing_key">
            <column name="tenant_id" type="VARCHAR(12)">
                <constraints nullable="false"/>
            </column>
            <column name="key_id" type="CHAR(12)">
                <constraints nullable="false"/>
            </column>
            <column name="full_key_id" type="VARCHAR(255)">
                <constraints nullable="false"/>
            </column>
            <column name="timestamp" type="TIMESTAMP">
                <constraints nullable="false"/>
            </column>
            <column name="category" type="VARCHAR(64)">
                <constraints nullable="false"/>
            </column>
            <column name="scheme_code_name" type="VARCHAR(64)">
                <constraints nullable="false"/>
            </column>
            <column name="public_key" type="VARBINARY(1048576)">
                <constraints nullable="false"/>
            </column>
            <column name="key_material" type="VARBINARY(1048576)">
                <constraints nullable="true"/>
            </column>
            <column name="encoding_version" type="INT">
                <constraints nullable="true"/>
            </column>
            <column name="master_key_alias" type="VARCHAR(64)">
                <constraints nullable="true"/>
            </column>
            <column name="alias" type="VARCHAR(64)">
                <constraints nullable="true"/>
            </column>
            <column name="hsm_alias" type="VARCHAR(64)">
                <constraints nullable="true"/>
            </column>
            <column name="external_id" type="VARCHAR(64)">
                <constraints nullable="true"/>
            </column>
            <column name="hsm_id" type="VARCHAR(36)">
                <constraints nullable="false"/>
            </column>
            <column name="status" type="VARCHAR(16)">
                <constraints nullable="false"/>
            </column>
        </createTable>
        <addPrimaryKey constraintName="crypto_signing_key_pk"
                       tableName="crypto_signing_key"
                       columnNames="tenant_id, key_id"/>
        <createIndex indexName="crypto_signing_key_full_key_idx"
                     tableName="crypto_signing_key">
            <column name="tenant_id"/>
            <column name="full_key_id"/>
        </createIndex>
        <createIndex indexName="crypto_signing_key_tenant_idx"
                     tableName="crypto_signing_key">
            <column name="tenant_id"/>
        </createIndex>
        <createIndex indexName="crypto_signing_key_tenant_category_idx"
                     tableName="crypto_signing_key">
            <column name="tenant_id"/>
            <column name="category"/>
        </createIndex>
        <createIndex indexName="crypto_signing_key_tenant_alias_idx"
                     tableName="crypto_signing_key">
            <column name="tenant_id"/>
            <column name="alias"/>
        </createIndex>
    </changeSet>
</databaseChangeLog>