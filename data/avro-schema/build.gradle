import com.github.davidmc24.gradle.plugin.avro.GenerateAvroJavaTask
import groovy.io.FileType
import groovy.text.SimpleTemplateEngine

plugins {
    id 'org.jetbrains.kotlin.jvm'
    id 'com.r3.internal.gradle.plugins.r3Publish'
    id "com.github.davidmc24.gradle.plugin.avro-base"
    id 'biz.aQute.bnd.builder'
}

dependencies {
    api "org.apache.avro:avro:$avroVersion"
    implementation platform(project(':corda-platform'))
    implementation project(":base")

    compileOnly "org.osgi:osgi.annotation:$osgiVersion"
    compileOnly "org.osgi:osgi.core:$osgiVersion"
}

description 'Data Model Definitions'

def generatedAvroDir = layout.buildDirectory.dir('generated-avro')
def generatedPackageInfoDir = layout.buildDirectory.dir('generated-packages')
def generatedClassesDir = layout.buildDirectory.dir('generated-txt')

sourceSets {
    main {
        java {
            srcDirs generatedAvroDir, generatedPackageInfoDir
        }
    }
}

def generateAvro = tasks.register("generateAvro", GenerateAvroJavaTask) {
    group = "codeGeneration"
    source("src/main/resources/avro")
    outputDir = generatedAvroDir
}

avro {
    fieldVisibility = "PRIVATE"
}

// region Generate package-info.java
// The following code ensures that we have a `package-info.java` for every package that we
// generate through Avro

def generateOSGiPackageInfo = tasks.register("generateOSGiPackageInfo", Task) {
    group = "codeGeneration"
    def packages = [] as Set<String>
    def classes = [] as Set<String>

    inputs.files generateAvro
    outputs.dirs generatedPackageInfoDir, generatedClassesDir

    doLast {
        generatedAvroDir.get().asFile.eachFileRecurse(FileType.FILES) {
            if (!it.name.contains("package-info") && it.name.endsWith('.java')) {
                def packageName = ((it.text =~ "package (.+);")[0][1])
                packages << packageName
                def classCapture = it.text.normalize() =~ "@org.apache.avro.specific.AvroGenerated\npublic class (\\w+) extends org.apache.avro.specific.SpecificRecordBase"
                if (classCapture.any()) {
                    classes << packageName + '.' + classCapture[0][1]
                }
            }
        }

        def packageInfoDir = generatedPackageInfoDir.get()
        packages.each { String pkg ->
            def dir = packageInfoDir.dir(pkg.replaceAll(/\./, '/'))
            mkdir dir
            dir.file('package-info.java').asFile.withWriter { outputFile ->
                outputFile << applyPackageInfoTemplate(pkg)
            }
        }

        generatedClassesDir.map { dir ->
            dir.file('generated-avro-message-classes.txt')
        }.get().asFile.withPrintWriter { outputFile ->
            for (String generatedClass in classes.sort()) {
                outputFile.println generatedClass.denormalize()
            }
        }
    }
}

private static String applyPackageInfoTemplate(packageName) {
    def engine = new SimpleTemplateEngine()
    def templateText =
            """/**
 * Autogenerated by R3
 *
 * DO NOT EDIT DIRECTLY
 */
@Export
package $packageName;

import org.osgi.annotation.bundle.Export;
"""
    def templateParams = ['packageName': packageName]
    engine.createTemplate(templateText).make(templateParams).toString().denormalize()
}
// endregion

tasks.named("compileKotlin") {
    dependsOn generateOSGiPackageInfo
}

def generatedResources = files(generatedClassesDir) {
    builtBy generateOSGiPackageInfo
}

tasks.named('processResources', ProcessResources) {
    from(generatedResources) {
        into 'net/corda/data'
    }
}

/**
 * Make this bundle a fragment of the Avro bundle to allow Avro to classload
 * all the classes from this bundle.
 */
tasks.named('jar', Jar) {
    bnd """
Bundle-Name: \${project.description}
Bundle-SymbolicName: \${project.group}.\${project.name}
Fragment-Host: avro
"""
}
