import com.github.davidmc24.gradle.plugin.avro.GenerateAvroJavaTask
import groovy.io.FileType
import groovy.text.SimpleTemplateEngine

plugins {
    id 'corda-api.common-library'
    id 'corda.common-publishing'
    id 'corda.java-only'
    id "com.github.davidmc24.gradle.plugin.avro-base"
}

dependencies {
    api libs.avro
    constraints {
        implementation("com.fasterxml.jackson.core:jackson-databind:$jacksonVersion") {
            because "required until new version of Avro available which updates Jackson"
        }

        implementation(libs.commons.compress) {
            because "CVE-2023-42503, current version of Avro uses an outdated version"
        }
    }

    implementation platform(project(':corda-api'))
    implementation project(':base')
    compileOnly 'org.jetbrains:annotations'
    compileOnly 'org.osgi:osgi.annotation'
}

configurations.all {
    resolutionStrategy {
        // CVE-2023-42503, current version of Avro uses an outdated version
        force libs.commons.compress
    }
}

description 'Data Model Definitions'

def generatedAvroDir = layout.buildDirectory.dir('generated-avro')
def generatedPackageInfoDir = layout.buildDirectory.dir('generated-packages')
def generatedClassesDir = layout.buildDirectory.dir('generated-txt')

sourceSets {
    main {
        java {
            srcDirs generatedAvroDir, generatedPackageInfoDir
        }
    }
}

def generateAvro = tasks.register("generateAvro", GenerateAvroJavaTask) {
    outputs.cacheIf { false }
    outputs.upToDateWhen { false }
    group = "codeGeneration"
    source("src/main/resources/avro")
    outputDir = generatedAvroDir
}

avro {
    fieldVisibility = "PRIVATE"
}

// region Generate package-info.java
// The following code ensures that we have a `package-info.java` for every package that we
// generate through Avro

def generateOSGiPackageInfo = tasks.register("generateOSGiPackageInfo", Task) {
    outputs.cacheIf { false }
    group = "codeGeneration"
    def packages = [] as Set<String>
    def classes = [] as Set<String>

    inputs.files generateAvro
    outputs.dirs generatedPackageInfoDir, generatedClassesDir

    doLast {
        generatedAvroDir.get().asFile.eachFileRecurse(FileType.FILES) {
            if (!it.name.contains("package-info") && it.name.endsWith('.java')) {
                def packageName = ((it.text =~ "package (.+);")[0][1])
                packages << packageName
                def normalizedText = it.text.normalize()
                def specificRecordBaseClassCapture = normalizedText =~ "@org.apache.avro.specific.AvroGenerated\npublic class (\\w+) extends org.apache.avro.specific.SpecificRecordBase"
                if (specificRecordBaseClassCapture.any()) {
                    classes << packageName + '.' + specificRecordBaseClassCapture[0][1]
                }
                def specificFixedClassCapture = normalizedText =~ "@org.apache.avro.specific.AvroGenerated\npublic class (\\w+) extends org.apache.avro.specific.SpecificFixed"
                if (specificFixedClassCapture.any()) {
                    classes << packageName + '.' + specificFixedClassCapture[0][1]
                }
            }
        }

        def packageInfoDir = generatedPackageInfoDir.get()
        packages.each { String pkg ->
            def dir = packageInfoDir.dir(pkg.replaceAll(/\./, '/'))
            mkdir dir
            dir.file('package-info.java').asFile.withWriter { outputFile ->
                outputFile << applyPackageInfoTemplate(pkg)
            }
        }

        generatedClassesDir.map { dir ->
            dir.file('generated-avro-message-classes.txt')
        }.get().asFile.withPrintWriter { outputFile ->
            for (String generatedClass in classes.sort()) {
                outputFile.println generatedClass.denormalize()
            }
        }
    }
}

private static String applyPackageInfoTemplate(packageName) {
    def engine = new SimpleTemplateEngine()
    def templateText =
            """/**
 * Autogenerated by R3
 *
 * DO NOT EDIT DIRECTLY
 */
@Export
package $packageName;

import org.osgi.annotation.bundle.Export;
"""
    def templateParams = ['packageName': packageName]
    engine.createTemplate(templateText).make(templateParams).toString().denormalize()
}
// endregion

tasks.named("compileJava") {
    dependsOn generateOSGiPackageInfo
}

tasks.named('dokkaHtml') {
    inputs.files generateAvro, generateOSGiPackageInfo
}

tasks.named('dokkaHtmlPartial'){
    mustRunAfter generateAvro, generateOSGiPackageInfo
}

tasks.named('kotlinSourcesJar'){
    mustRunAfter generateAvro, generateOSGiPackageInfo
}

def generatedResources = files(generatedClassesDir) {
    builtBy generateOSGiPackageInfo
}

tasks.named('processResources', ProcessResources) {
    from(generatedResources) {
        into 'net/corda/data'
    }
}

/**
 * Make this bundle a fragment of the Avro bundle to allow Avro to classload
 * all the classes from this bundle.
 */
tasks.named('jar', Jar) {
    bundle {
        bnd '''\
Fragment-Host: avro
'''
    }
}

tasks.named("sourcesJar", Jar) {
    inputs.files(generateAvro)
    inputs.files(generateOSGiPackageInfo)
}
