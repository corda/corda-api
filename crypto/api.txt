package @org.osgi.annotation.bundle.Export net.corda.v5.crypto {

  public interface CompositeKey {
    method public void checkValidity();
    method @NonNull public Set<PublicKey> getLeafKeys();
    method public boolean isFulfilledBy(@NonNull PublicKey);
    method public boolean isFulfilledBy(@NonNull Set<PublicKey>);
  }

  public final class CompositeKeyNodeAndWeight {
    ctor public CompositeKeyNodeAndWeight(@NonNull PublicKey, int);
    ctor public CompositeKeyNodeAndWeight(@NonNull PublicKey);
    method public boolean equals(Object);
    method @NonNull public PublicKey getNode();
    method public int getWeight();
    method public int hashCode();
    method @NonNull public String toString();
  }

  public final class CordaOID {
    field @NonNull public static final String OID_ALIAS_PRIVATE_KEY;
    field @NonNull public static final String OID_COMPOSITE_KEY;
    field @NonNull public static final String OID_COMPOSITE_SIGNATURE;
    field @NonNull public static final String OID_CORDA_PLATFORM;
    field @NonNull public static final String OID_R3_ROOT;
    field @NonNull public static final String OID_X509_EXTENSION_CORDA_ROLE;
  }

  @net.corda.v5.base.annotations.CordaSerializable public final class DigestAlgorithmName {
    ctor public DigestAlgorithmName(@NonNull String);
    method public boolean equals(@Nullable Object);
    method @NonNull public String getName();
    method public int hashCode();
    method @NonNull public String toString();
    field @NonNull public static final net.corda.v5.crypto.DigestAlgorithmName SHA2_256;
    field @NonNull public static final net.corda.v5.crypto.DigestAlgorithmName SHA2_256D;
    field @NonNull public static final net.corda.v5.crypto.DigestAlgorithmName SHA2_384;
    field @NonNull public static final net.corda.v5.crypto.DigestAlgorithmName SHA2_512;
  }

  public final class DigestAlgorithmNameTests {
    ctor public DigestAlgorithmNameTests();
    method public void equal should return false when comparing to null();
    method public void equal should return false when comparing to other types();
    method public void equal should return true when comparing to itself();
    method public void equal should return true when comparing to the equal value();
    method public void equal should return true when comparing to the value with different casing();
    method public void hasCode should be different value for the different values();
    method public void hasCode should be the same value for the same values();
    method public void hasCode should be the same value for the same values with different casing();
    method public void toString should return the wrapped algorithm name();
  }

  @net.corda.v5.base.annotations.CordaSerializable @net.corda.v5.base.annotations.DoNotImplement public interface DigitalSignature {
    method @NonNull public byte[] getBytes();
  }

  @net.corda.v5.base.annotations.DoNotImplement public static interface DigitalSignature.WithKeyId extends net.corda.v5.crypto.DigitalSignature {
    method @NonNull public net.corda.v5.crypto.SecureHash getBy();
  }

  public final class KeySchemeCodes {
    field @NonNull public static final String COMPOSITE_KEY_CODE_NAME;
    field @NonNull public static final String ECDSA_SECP256K1_CODE_NAME;
    field @NonNull public static final String ECDSA_SECP256R1_CODE_NAME;
    field @NonNull public static final String EDDSA_ED25519_CODE_NAME;
    field @NonNull public static final String GOST3410_GOST3411_CODE_NAME;
    field @NonNull public static final String RSA_CODE_NAME;
    field @NonNull public static final String SM2_CODE_NAME;
    field @NonNull public static final String SPHINCS256_CODE_NAME;
    field @NonNull public static final String X25519_CODE_NAME;
  }

  public final class KeyUtils {
    method public static boolean isKeyFulfilledBy(@NonNull PublicKey, @NonNull Set<PublicKey>);
    method public static boolean isKeyFulfilledBy(@NonNull PublicKey, @NonNull PublicKey);
    method public static boolean isKeyInSet(@NonNull PublicKey, @NonNull Set<PublicKey>);
  }

  public final class KeyUtilsTests {
    ctor public KeyUtilsTests();
    method public void isKeyFulfilledBy overload with collection should return false if the keys are not matching at least one given public key(@NonNull error.NonExistentClass key);
    method public void isKeyFulfilledBy overload with collection should return true if the keys are matching at least one given public key(@NonNull error.NonExistentClass key);
    method public void isKeyFulfilledBy overload with single key should return false if the keys are not matching for a given public key(@NonNull error.NonExistentClass key);
    method public void isKeyFulfilledBy overload with single key should return true if the keys are matching for a given public key(@NonNull error.NonExistentClass key);
    method public void isKeyInSet claims a key is in a member of single-element set containing that key(@NonNull error.NonExistentClass key);
    method public void isKeyInSet claims a key is not a member of single-element set containing another key(@NonNull error.NonExistentClass key);
    field @NonNull public static final net.corda.v5.crypto.KeyUtilsTests.Companion Companion;
  }

  public static final class KeyUtilsTests.Companion {
    method public error.NonExistentClass getOther();
    method @NonNull public java.util.List<error.NonExistentClass> publicKeys();
    property public final error.NonExistentClass other;
  }

  public final class MessageAuthenticationCode {
    field @NonNull public static final String HMAC_SHA256_ALGORITHM;
    field @NonNull public static final String HMAC_SHA512_ALGORITHM;
  }

  @net.corda.v5.base.annotations.CordaSerializable @net.corda.v5.base.annotations.DoNotImplement public interface SecureHash {
    method @NonNull public String getAlgorithm();
    method @NonNull public String toHexString();
    method @NonNull public String toString();
    field public static final char DELIMITER = 58; // 0x003a ':'
  }

  @net.corda.v5.base.annotations.CordaSerializable @net.corda.v5.base.annotations.DoNotImplement public interface SignatureSpec {
    method @NonNull public String getSignatureName();
  }

}

package @org.osgi.annotation.bundle.Export net.corda.v5.crypto.exceptions {

  @net.corda.v5.base.annotations.CordaSerializable public class CryptoException extends net.corda.v5.base.exceptions.CordaRuntimeException {
    ctor public CryptoException(@NonNull String);
    ctor public CryptoException(@NonNull String, boolean);
    ctor public CryptoException(@NonNull String, @Nullable Throwable);
    ctor public CryptoException(@NonNull String, boolean, @Nullable Throwable);
    method public final boolean isRecoverable();
  }

  @net.corda.v5.base.annotations.CordaSerializable public final class CryptoSignatureException extends net.corda.v5.crypto.exceptions.CryptoException {
    ctor public CryptoSignatureException(@NonNull String);
    ctor public CryptoSignatureException(@NonNull String, @Nullable Throwable);
  }

}

package @org.osgi.annotation.bundle.Export net.corda.v5.crypto.merkle {

  public final class HashDigestConstants {
    field @NonNull public static final String HASH_DIGEST_PROVIDER_DEFAULT_NAME;
    field @NonNull public static final String HASH_DIGEST_PROVIDER_ENTROPY_OPTION;
    field @NonNull public static final String HASH_DIGEST_PROVIDER_LEAF_PREFIX_OPTION;
    field @NonNull public static final String HASH_DIGEST_PROVIDER_NODE_PREFIX_OPTION;
    field @NonNull public static final String HASH_DIGEST_PROVIDER_NONCE_NAME;
    field @NonNull public static final String HASH_DIGEST_PROVIDER_NONCE_SIZE_ONLY_VERIFY_NAME;
    field @NonNull public static final String HASH_DIGEST_PROVIDER_NONCE_VERIFY_NAME;
    field @NonNull public static final String HASH_DIGEST_PROVIDER_TWEAKABLE_NAME;
  }

  @net.corda.v5.base.annotations.CordaSerializable @net.corda.v5.base.annotations.DoNotImplement public interface IndexedMerkleLeaf {
    method public int getIndex();
    method @NonNull public byte[] getLeafData();
    method @Nullable public byte[] getNonce();
  }

  @net.corda.v5.base.annotations.CordaSerializable @net.corda.v5.base.annotations.DoNotImplement public interface MerkleProof {
    method public net.corda.v5.crypto.SecureHash calculateRoot(@NonNull net.corda.v5.crypto.merkle.MerkleTreeHashDigest);
    method public List<SecureHash> getHashes();
    method public List<IndexedMerkleLeaf> getLeaves();
    method @NonNull public net.corda.v5.crypto.merkle.MerkleProofType getProofType();
    method public int getTreeSize();
    method public boolean verify(@NonNull net.corda.v5.crypto.SecureHash, @NonNull net.corda.v5.crypto.merkle.MerkleTreeHashDigest);
  }

  public final class MerkleProofRebuildFailureException extends net.corda.v5.base.exceptions.CordaRuntimeException {
    ctor public MerkleProofRebuildFailureException(@NonNull String);
  }

  @net.corda.v5.base.annotations.CordaSerializable public enum MerkleProofType {
    enum_constant public static final net.corda.v5.crypto.merkle.MerkleProofType AUDIT;
    enum_constant public static final net.corda.v5.crypto.merkle.MerkleProofType SIZE;
  }

  @net.corda.v5.base.annotations.DoNotImplement public interface MerkleTree {
    method @NonNull public net.corda.v5.crypto.merkle.MerkleProof createAuditProof(@NonNull List<Integer>);
    method @NonNull public net.corda.v5.crypto.merkle.MerkleTreeHashDigest getDigest();
    method @NonNull public List<byte[]> getLeaves();
    method @NonNull public net.corda.v5.crypto.SecureHash getRoot();
  }

  public interface MerkleTreeHashDigest {
    method @NonNull public net.corda.v5.crypto.DigestAlgorithmName getDigestAlgorithmName();
  }

}

package net.corda.v5.crypto.mocks {

  public final class CryptoTestUtils {
    method public static error.NonExistentClass createDevCertificate(@NonNull error.NonExistentClass issuer, @NonNull error.NonExistentClass contentSigner, @NonNull error.NonExistentClass subject, @NonNull error.NonExistentClass subjectPublicKey);
    method public static error.NonExistentClass generateKeyPair(@NonNull net.corda.v5.crypto.mocks.KeySpec spec);
    method public static error.NonExistentClass getDevSigner(@NonNull error.NonExistentClass privateKey, @NonNull error.NonExistentClass signatureAlgorithm);
    method @NonNull public static net.corda.v5.crypto.mocks.KeySpec getECDSA_SECP256K1_SPEC();
    method @NonNull public static net.corda.v5.crypto.mocks.KeySpec getECDSA_SECP256R1_SPEC();
    method @NonNull public static net.corda.v5.crypto.mocks.KeySpec getEDDSA_ED25519_SPEC();
    method @NonNull public static net.corda.v5.crypto.mocks.KeySpec getRSA_SPEC();
    method @NonNull public static java.util.Map<error.NonExistentClass,net.corda.v5.crypto.mocks.KeySpec> getSpecs();
    property @NonNull public static final net.corda.v5.crypto.mocks.KeySpec ECDSA_SECP256K1_SPEC;
    property @NonNull public static final net.corda.v5.crypto.mocks.KeySpec ECDSA_SECP256R1_SPEC;
    property @NonNull public static final net.corda.v5.crypto.mocks.KeySpec EDDSA_ED25519_SPEC;
    property @NonNull public static final net.corda.v5.crypto.mocks.KeySpec RSA_SPEC;
    property @NonNull public static final java.util.Map<error.NonExistentClass,net.corda.v5.crypto.mocks.KeySpec> specs;
  }

  public final class KeySpec {
    ctor public KeySpec(@NonNull String name, optional @Nullable error.NonExistentClass spec, optional @Nullable Integer keyLength);
    method @NonNull public String component1();
    method public error.NonExistentClass component2();
    method @Nullable public Integer component3();
    method @NonNull public net.corda.v5.crypto.mocks.KeySpec copy(@NonNull String name, error.NonExistentClass spec, @Nullable Integer keyLength);
    method public boolean equals(@Nullable Object other);
    method @Nullable public Integer getKeyLength();
    method @NonNull public String getName();
    method public error.NonExistentClass getSpec();
    method public int hashCode();
    method @NonNull public String toString();
    property @Nullable public final Integer keyLength;
    property @NonNull public final String name;
    property public final error.NonExistentClass spec;
  }

}

