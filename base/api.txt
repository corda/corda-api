package @org.osgi.annotation.bundle.Export net.corda.v5.base.annotations {

  @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS) public @interface ConstructorForDeserialization {
  }

  @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS) public @interface CordaSerializable {
  }

  @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS) public @interface DeprecatedConstructorForDeserialization {
    method public abstract int version();
  }

  @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS) public @interface DoNotImplement {
  }

  @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS) public @interface Suspendable {
  }

  @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS) public @interface VisibleForTesting {
  }

}

package @org.osgi.annotation.bundle.Export net.corda.v5.base.exceptions {

  public class CordaRuntimeException implements net.corda.v5.base.exceptions.CordaThrowable {
    ctor @net.corda.v5.base.annotations.ConstructorForDeserialization public CordaRuntimeException(@Nullable String, @Nullable String, @Nullable Throwable);
    ctor public CordaRuntimeException(@Nullable String, @Nullable Throwable);
    ctor public CordaRuntimeException(@Nullable String);
    method public void addSuppressed(@NonNull Throwable[]);
    method public boolean equals(@Nullable Object);
    method @Nullable public Throwable getCause();
    method @Nullable public String getMessage();
    method @Nullable public String getOriginalExceptionClassName();
    method @Nullable public String getOriginalMessage();
    method public int hashCode();
    method public void setCause(@Nullable Throwable);
    method public void setMessage(@Nullable String);
    method public void setOriginalExceptionClassName(@Nullable String);
  }

  public class CordaRuntimeExceptionJavaApiTest {
    ctor public CordaRuntimeExceptionJavaApiTest();
    method public void addSuppressed();
    method public void getCause();
    method public void getMessage();
    method public void getOriginalExceptionClassName();
    method public void getOriginalMessage();
    method public void setCause();
    method public void setMessage();
  }

  @net.corda.v5.base.annotations.CordaSerializable public interface CordaThrowable {
    method public void addSuppressed(@NonNull Throwable[]);
    method @Nullable public String getOriginalExceptionClassName();
    method @Nullable public String getOriginalMessage();
    method public void setCause(@Nullable Throwable);
    method public void setMessage(@Nullable String);
    method public void setOriginalExceptionClassName(@Nullable String);
  }

  public class CordaThrowableJavaApiTest {
    ctor public CordaThrowableJavaApiTest();
    method public void addSuppressed();
    method public void getOriginalExceptionClassName();
    method public void getOriginalMessage();
    method public void setCause();
    method public void setMessage();
  }

  public final class ValueNotFoundException extends net.corda.v5.base.exceptions.CordaRuntimeException {
    ctor public ValueNotFoundException(@Nullable String);
  }

}

package @org.osgi.annotation.bundle.Export net.corda.v5.base.types {

  public interface LayeredPropertyMap {
    method @Nullable public String get(@NonNull String);
    method @NonNull public Set<Map.Entry<String,String>> getEntries();
    method @NonNull public <T> T parse(@NonNull String, @NonNull Class<? extends T>);
    method @NonNull public <T> List<T> parseList(@NonNull String, @NonNull Class<? extends T>);
    method @Nullable public <T> T parseOrNull(@NonNull String, @NonNull Class<? extends T>);
    method @NonNull public <T> Set<T> parseSet(@NonNull String, @NonNull Class<? extends T>);
  }

  @net.corda.v5.base.annotations.CordaSerializable public final class MemberX500Name {
    ctor @net.corda.v5.base.annotations.ConstructorForDeserialization public MemberX500Name(@Nullable String, @Nullable String, @NonNull String, @NonNull String, @Nullable String, @NonNull String);
    ctor public MemberX500Name(@NonNull String, @NonNull String, @NonNull String, @NonNull String);
    ctor public MemberX500Name(@NonNull String, @NonNull String, @NonNull String);
    method @NonNull public static net.corda.v5.base.types.MemberX500Name build(@NonNull X500Principal);
    method public int compareTo(@NonNull net.corda.v5.base.types.MemberX500Name);
    method public boolean equals(@Nullable Object);
    method @Nullable public String getCommonName();
    method @NonNull public String getCountry();
    method @NonNull public String getLocality();
    method @NonNull public String getOrganization();
    method @Nullable public String getOrganizationUnit();
    method @Nullable public String getState();
    method @NonNull public X500Principal getX500Principal();
    method public int hashCode();
    method @NonNull public static net.corda.v5.base.types.MemberX500Name parse(@NonNull String);
    method @NonNull public static Map<String,String> toAttributesMap(@NonNull String);
    method @NonNull public String toString();
    field public static final int MAX_LENGTH_COMMON_NAME = 64; // 0x40
    field public static final int MAX_LENGTH_LOCALITY = 64; // 0x40
    field public static final int MAX_LENGTH_ORGANIZATION = 128; // 0x80
    field public static final int MAX_LENGTH_ORGANIZATION_UNIT = 64; // 0x40
    field public static final int MAX_LENGTH_STATE = 64; // 0x40
  }

  public final class MemberX500NameTest {
    ctor public MemberX500NameTest();
    method public void Equality with different type should return false();
    method public void Equality with null should return false();
    method public void Should build attributes map from X500 name string();
    method public void Should build from X500Principal();
    method public void Should build from X500Principal with properly escaped X500 name string();
    method public void Should create MemberX500Name without commonName, organizationUnit and state();
    method public void Should create MemberX500Name without organizationUnit and state();
    method public void Should output string in predictable order();
    method public void Should parse attributes starting with lower case letter();
    method public void Should parse attributes starting with numeric character();
    method public void Should parse attributes with leading whitespace();
    method public void Should parse attributes with single quotation mark();
    method public void Should parse attributes with trailing whitespace();
    method public void Should parse properly escaped X500 name string();
    method public void Should parse string containing unspecified country code();
    method public void Should parse string without state();
    method public void Should parse string without state and organizational unit();
    method public void Should parse string without state, organizational unit and common name();
    method public void Should parse value with dollar sign();
    method public void Should parse value with equals sign();
    method public void Should throw IllegalArgumentException for attributes with backslash();
    method public void Should throw IllegalArgumentException for attributes with double quotation mark();
    method public void Should throw IllegalArgumentException parsing X500 name string with duplicate attribute();
    method public void Should throw IllegalArgumentException parsing X500 name string with multi-valued RDN();
    method public void Should throw IllegalArgumentException parsing malformed string();
    method public void Should throw IllegalArgumentException when common name exceeds max length();
    method public void Should throw IllegalArgumentException when common name is blank();
    method public void Should throw IllegalArgumentException when country is blank();
    method public void Should throw IllegalArgumentException when country is not known();
    method public void Should throw IllegalArgumentException when country is not present();
    method public void Should throw IllegalArgumentException when locality exceeds max length();
    method public void Should throw IllegalArgumentException when locality is blank();
    method public void Should throw IllegalArgumentException when locality is not present();
    method public void Should throw IllegalArgumentException when name has unsupported attribute();
    method public void Should throw IllegalArgumentException when organization exceeds max length();
    method public void Should throw IllegalArgumentException when organization is blank();
    method public void Should throw IllegalArgumentException when organization is not present();
    method public void Should throw IllegalArgumentException when organizational unit exceeds max length();
    method public void Should throw IllegalArgumentException when organizational unit is blank();
    method public void Should throw IllegalArgumentException when state exceeds max length();
    method public void Should throw IllegalArgumentException when state is blank();
    method public void Should throw IllegalArgumentsException when build attributes map from string with unsupported attribute();
    method public void Two names constructed from same attributes but in different order must be equal();
    method public void Two names constructed from same required attributes but in different order must be equal();
    method public void should give the correct order();
  }

}

package @org.osgi.annotation.bundle.Export net.corda.v5.base.util {

  public class Base58 {
    ctor public Base58();
    method public static byte[] decode(String);
    method public static BigInteger decodeToBigInteger(String);
    method public static String encode(byte[]);
  }

  public final class Base58Test {
    ctor public Base58Test();
    method public void testDecode();
    method public void testDecodeToBigInteger();
    method public void testEncode();
  }

  public final class ByteArrays {
    method @NonNull public static byte[] parseAsHex(@NonNull String);
    method @NonNull public static String toHexString(@NonNull byte[]);
  }

  public final class EncodingUtils {
    method @NonNull public static byte[] base58ToByteArray(@NonNull String);
    method @NonNull public static String base58ToRealString(@NonNull String);
    method @NonNull public static String base58toBase64(@NonNull String);
    method @NonNull public static String base58toHex(@NonNull String);
    method @NonNull public static byte[] base64ToByteArray(@NonNull String);
    method @NonNull public static String base64ToRealString(@NonNull String);
    method @NonNull public static String base64toBase58(@NonNull String);
    method @NonNull public static String base64toHex(@NonNull String);
    method @NonNull public static String hexToBase58(@NonNull String);
    method @NonNull public static String hexToBase64(@NonNull String);
    method @NonNull public static byte[] hexToByteArray(@NonNull String);
    method @NonNull public static String hexToRealString(@NonNull String);
    method @NonNull public static String toBase58(@NonNull byte[]);
    method @NonNull public static String toBase64(@NonNull byte[]);
    method @NonNull public static String toHex(@NonNull byte[]);
  }

  public final class EncodingUtilsTest {
    ctor public EncodingUtilsTest();
    method public void change encoding between base58, base64, hex();
    method public void decoding empty Strings();
    method public void decoding lowercase and mixed HEX();
    method public void decoding on wrong format();
    method public void decoding to real String();
    method public void empty encoding();
    method public void encoding 7 zero bytes();
    method public void encoding Hello World();
    method @NonNull public String getTestBase58String();
    method @NonNull public String getTestBase64String();
    method public error.NonExistentClass getTestBytes();
    method @NonNull public String getTestHexString();
    method @NonNull public String getTestString();
    property @NonNull public final String testBase58String;
    property @NonNull public final String testBase64String;
    property public final error.NonExistentClass testBytes;
    property @NonNull public final String testHexString;
    property @NonNull public final String testString;
  }

}

package @org.osgi.annotation.bundle.Export net.corda.v5.base.versioning {

  public final class Version {
    ctor public Version(int, int);
    method public boolean equals(@Nullable Object);
    method public static net.corda.v5.base.versioning.Version fromString(@NonNull String);
    method public int getMajor();
    method public int getMinor();
    method public int hashCode();
    method @NonNull public String toString();
  }

  public final class VersionTest {
    ctor public VersionTest();
    method public void parse a version from invalid version strings(@NonNull String versionString);
    method public void parse a version from valid version strings();
  }

}

